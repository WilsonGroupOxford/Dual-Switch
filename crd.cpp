#include "crd.h"

Crd2d::Crd2d() {
    x=0.0;
    y=0.0;
    return;
}

Crd2d::Crd2d(double xInit, double yInit) {
    x=xInit;
    y=yInit;
    return;
}

Pair::Pair() {
    a=0;
    b=0;
    return;
}

Pair::Pair(int aInit, int bInit) {
    a=aInit;
    b=bInit;
    return;
}

DoublePair::DoublePair() {
    a=0;
    b=0;
    c=0;
    d=0;
    return;
}

DoublePair::DoublePair(int aInit, int bInit, int cInit, int dInit) {
    a=aInit;
    b=bInit;
    c=cInit;
    d=dInit;
    return;
}

void DoublePair::sort() {
    int e,f;
    if(a>b){
        e=a;
        a=b;
        b=e;
    }
    if(c>d){
        f=c;
        c=d;
        d=f;
    }
    if(a>c){
        e=a;
        f=b;
        a=c;
        b=d;
        c=e;
        d=f;
    }
    return;
}

string DoublePair::getID() {
    return "#"+to_string(a)+"#"+to_string(b)+"#"+to_string(c)+"#"+to_string(d);
}



Vec2d::Vec2d() {
    //initialise to null
    x=0.0;
    y=0.0;
    return;
}

Vec2d::Vec2d(double xInit, double yInit) {
    //initialise to vector
    x=xInit;
    y=yInit;
    return;
}

Vec2d::Vec2d(Crd2d c1, Crd2d c2) {
    //intialise with coordinates
    x=c2.x-c1.x;
    y=c2.y-c1.y;
    return;
}

Vec2d::Vec2d(Crd2d c1, Crd2d c2, double pbcX, double pbcY, double rX, double rY) {
    //intialise with coordinates and periodic boundary conditions
    x=(c2.x-c1.x);
    y=(c2.y-c1.y);
    x=x-pbcX*round(x*rX);
    y=y-pbcY*round(y*rY);
    return;
}

double Vec2d::length() {
    //length of vector
    return sqrt(x*x+y*y);
}

void Vec2d::normalise() {
    //make unit vector
    double norm=length();
    x=x/norm;
    y=y/norm;
    return;
}

void Vec2d::rotate90() {
    //rotate by 90 degrees (if unit)
    double xx=x, yy=y;
    x=-yy;
    y=xx;
    return;
}

void Vec2d::addVector(Vec2d v) {
    x=x+v.x;
    y=y+v.y;
    return;
}


double crdDistance(Crd2d &c1, Crd2d &c2){
    //distance between two coordiates in 2d
    return sqrt((c2.x-c1.x)*(c2.x-c1.x)+(c2.y-c1.y)*(c2.y-c1.y));
}

Crd2d recentreCrdByCrd(Crd2d &c1, Crd2d &c2){
    //shift c2 relative to c1
    return Crd2d((c2.x-c1.x),(c2.y-c1.y));
}
Crd2d recentreCrdByCrd(Crd2d &c1, Crd2d &c2, double &x, double &y, double &rX, double &rY){
    //shift c2-c1 with periodic boundary conditions
    Crd2d c((c2.x-c1.x),(c2.y-c1.y));
    c.x=c.x-x*round(c.x*rX);
    c.y=c.y-y*round(c.y*rY);
    return c;
}

Crd2d crdFromVectorAndCrd(Vec2d &v, Crd2d &c){
    //coordinate generated by placing vector on coordinate
    return Crd2d((c.x+v.x),(c.y+v.y));
}

double vectorDotProduct(Vec2d &v1, Vec2d &v2){
    //dot product
    return v1.x*v2.x+v1.y*v2.y;
}

//##### IMPLEMENTED USING COMPUTATIONAL GEOMETRY IN C #######
double signedAreaSqTriangle(Crd2d &a, Crd2d &b, Crd2d &c){
    //returns square of the signed area of a triangle defined by three points
    return a.x*b.y-a.y*b.x+a.y*c.x-a.x*c.y+b.x*c.y-c.x*b.y;
}
bool leftTriangle(Crd2d &a, Crd2d &b, Crd2d &c){
    //returns true if the signed area squared of a triangle is positive
    return signedAreaSqTriangle(a,b,c)>0.0;
}
bool collinearPoints(Crd2d &a, Crd2d &b, Crd2d &c, double threshold){
    //returns true if points are colliear within given threshold
    return fabs(signedAreaSqTriangle(a,b,c))<threshold;
}
bool properIntersectionLines(Crd2d &l1a, Crd2d &l1b, Crd2d &l2a, Crd2d &l2b){
    //returns true if lines properly intersect i.e. no points collinear
    if(collinearPoints(l1a,l1b,l2a) || collinearPoints(l1a,l1b,l2b) || collinearPoints(l2a,l2b,l1a) || collinearPoints(l2a,l2b,l1b)) return false;
    return (leftTriangle(l1a,l1b,l2a)^leftTriangle(l1a,l1b,l2b)) && (leftTriangle(l2a,l2b,l1a)^leftTriangle(l2a,l2b,l1b));
}
// ########## END ##########

vector<double> leastSquaresLinearRegression(vector<Crd2d> &data){
    //perform least squares linear regression and return gradient, intercept and r-squared
    vector<double> coefficients(3); //gradient, intercept and r-squared
    int n=data.size();
    double sumX=0.0, sumY=0.0, sumXY=0.0, sumXX=0.0, sumYY=0.0;
    for(int i=0; i<n; ++i){
        sumX=sumX+data[i].x;
        sumY=sumY+data[i].y;
        sumXY=sumXY+data[i].x*data[i].y;
        sumXX=sumXX+data[i].x*data[i].x;
        sumYY=sumYY+data[i].y*data[i].y;
    }
    double sqSumX=sumX*sumX, sqSumY=sumY*sumY;
    double sdX=sqrt(n*sumXX-sqSumX), sdY=sqrt(n*sumYY-sqSumY);
    double r=(n*sumXY-sumX*sumY)/(sdX*sdY);
    coefficients[0]=(r*sdY)/sdX;
    coefficients[1]=(sumY-coefficients[0]*sumX)/n;
    coefficients[2]=r*r;
    return coefficients;
}


